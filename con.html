<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Football Prediction Consensus Analyzer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #3f51b5;
            --primary-dark: #303f9f;
            --secondary: #ff5722;
            --success: #4caf50;
            --danger: #f44336;
            --light: #f5f5f5;
            --gray: #757575;
            --light-gray: #e0e0e0;
            --white: #ffffff;
            --home-win: #e3f2fd;
            --away-win: #ffebee;
            --card-shadow: 0 4px 16px rgba(0,0,0,0.12);
        }
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            background: linear-gradient(135deg, #e3e6f3 0%, #f5f5f5 100%);
            color: var(--primary-dark);
        }
        header {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            color: var(--white);
            padding: 36px 0 28px;
            box-shadow: var(--card-shadow);
            border-radius: 0 0 24px 24px;
            text-align: center;
        }
        .container {
            max-width: 800px;
            margin: 48px auto 0 auto;
            padding: 10px;
        }
        .card {
            background: var(--white);
            border-radius: 14px;
            box-shadow: var(--card-shadow);
            padding: 32px 24px;
            margin-bottom: 28px;
        }
        h1 {
            font-size: 2rem;
            font-weight: 700;
            letter-spacing: -1px;
        }
        h2 {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 22px;
            color: var(--primary);
        }
        .file-input label {
            font-size: 1rem;
            font-weight: 500;
            color: var(--gray);
            margin-bottom: 12px;
            display: block;
        }
        .file-input input[type="file"] {
            display: none;
        }
        .custom-upload {
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px dashed var(--primary);
            background: var(--light);
            border-radius: 10px;
            padding: 32px 0;
            cursor: pointer;
            transition: border-color 0.2s;
        }
        .custom-upload.dragover {
            border-color: var(--secondary);
            background: #e3e6f3;
        }
        .custom-upload i {
            font-size: 2.1rem;
            color: var(--primary);
            margin-right: 12px;
        }
        .custom-upload span {
            font-size: 1rem;
            color: var(--primary-dark);
            font-weight: 500;
        }
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: var(--primary);
            color: var(--white);
            border: none;
            padding: 14px 32px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.07rem;
            font-weight: 600;
            margin-top: 30px;
            box-shadow: 0 2px 5px rgba(63,81,181,0.08);
            transition: background 0.2s;
        }
        .btn i { margin-right: 10px; }
        .btn:disabled { background: var(--light-gray); color: var(--gray); cursor: not-allowed; }
        .progress-container {
            width: 100%;
            background: var(--light-gray);
            border-radius: 6px;
            margin: 24px 0 0;
            height: 10px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 6px;
            width: 0%;
            transition: width 0.5s;
        }
        .stats {
            display: flex;
            gap: 24px;
            margin-bottom: 18px;
            flex-wrap: wrap;
        }
        .stat-card {
            background: var(--light);
            border-radius: 10px;
            padding: 18px 30px;
            box-shadow: 0 2px 10px rgba(63,81,181,0.05);
            text-align: center;
            min-width: 140px;
            flex: 1 0 140px;
        }
        .stat-card h3 { font-size: 1rem; font-weight: 500; color: var(--gray); margin-bottom: 7px; }
        .stat-card p { font-size: 1.2rem; font-weight: 700; color: var(--primary); }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 12px;
            font-size: 1rem;
            border-radius: 10px 10px 0 0;
            overflow: hidden;
            background: var(--white);
        }
        th, td {
            padding: 14px 10px;
            border-bottom: 1px solid var(--light-gray);
            vertical-align: middle;
        }
        th { background: var(--primary); color: var(--white); font-weight: 600; }
        tr:last-child td { border-bottom: none; }
        tr.highlight { background: #e9f7ef; }
        tr.home-win { background: var(--home-win); }
        tr.away-win { background: var(--away-win); }
        tr:hover { background: rgba(63,81,181,0.07); }
        .sources-list { display: flex; flex-wrap: wrap; gap: 6px; }
        .source-badge {
            background: var(--light-gray);
            color: var(--gray);
            padding: 4px 10px;
            border-radius: 5px;
            font-size: 0.85rem;
            font-weight: 500;
        }
        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--gray);
        }
        .empty-state i { font-size: 3rem; color: var(--light-gray); margin-bottom: 12px;}
        .match-time { font-size: 0.95rem; color: var(--gray); margin-top: 3px;}
        .badge {
            margin-left: 10px;
            background: var(--primary);
            color: white;
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 0.85rem;
            font-weight: 500;
            letter-spacing: 0.5px;
        }
        .select-btn {
            background: var(--secondary);
            color: var(--white);
            border: none;
            padding: 8px 18px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            margin-top: 5px;
            min-width: 80px;
            transition: background .2s;
        }
        .select-btn.selected {
            background: var(--success);
        }
        .export-btn-container {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 10px;
            gap: 10px;
        }
        .delete-btn {
            background: var(--danger);
            color: var(--white);
            border: none;
            padding: 8px 18px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: background .2s;
        }
        .clear-btn {
            background: var(--gray);
            color: var(--white);
            border: none;
            padding: 8px 18px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: background .2s;
        }
        /* Tabs styling */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--light-gray);
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            font-weight: 600;
            color: var(--gray);
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
        }
        .tab.active {
            color: var(--primary);
            border-bottom: 3px solid var(--primary);
        }
        .tab:hover:not(.active) {
            color: var(--primary-dark);
            border-bottom: 3px solid var(--light-gray);
        }
        /* PNG Export Table Styling */
        .export-png-table {
            width: 700px;
            margin: 0 auto;
            border-radius: 14px;
            font-family: 'Inter', sans-serif;
            background: #fff;
            box-shadow: var(--card-shadow);
            border-collapse: separate;
            border-spacing: 0;
            overflow: hidden;
        }
        .export-png-table th {
            background: var(--primary);
            color: #fff;
            font-size: 1.15rem;
            font-weight: 600;
            padding: 18px 10px;
            border-right: 2px solid #fff;
        }
        .export-png-table th:last-child {
            border-right: none;
        }
        .export-png-table td {
            padding: 14px 10px;
            font-size: 1rem;
            text-align: center;
            border-bottom: 1px solid var(--light-gray);
        }
        .export-png-table tr:last-child td {
            border-bottom: none;
        }
        .export-png-table .team-cell {
            font-weight: 600;
            font-size: 1.07rem;
            color: var(--primary-dark);
        }
        .export-png-table .prediction-cell {
            font-size: 1.07rem;
            font-weight: 500;
            color: var(--secondary);
            background: #ffe6df;
            border-radius: 6px;
            padding: 7px 8px;
            margin: 3px 0;
        }
        .export-png-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--primary);
            padding: 18px 0 5px 0;
            text-align: center;
            letter-spacing: -1px;
        }
        .export-png-time {
            font-size: 0.98rem;
            color: var(--gray);
            font-weight: 500;
            margin-bottom: 8px;
        }
        .local-time {
            font-size: 0.85rem;
            color: #666;
            margin-top: 3px;
        }
        .home-win-export {
            background-color: var(--home-win);
        }
        .away-win-export {
            background-color: var(--away-win);
        }
        .export-type-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        .home-badge {
            background-color: var(--primary);
            color: white;
        }
        .away-badge {
            background-color: var(--danger);
            color: white;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
</head>
<body>
<header>
    <h1>Football Prediction Consensus Analyzer</h1>
    <div style="font-size:1.1rem;opacity:.95;margin-top:10px;">Upload predictions from multiple sources. Fuzzy match, select, and export consensus matches.</div>
</header>
<div class="container">
    <div class="card upload-section">
        <h2><i class="fas fa-upload"></i> Upload Prediction Files</h2>
        <div class="file-input">
            <label for="file-multi">Select CSV Prediction Files (2 to 10)</label>
            <label class="custom-upload" id="custom-upload" for="file-multi">
                <i class="fas fa-cloud-upload-alt"></i>
                <span id="upload-label-text">Click or drag to upload files</span>
            </label>
            <input type="file" id="file-multi" accept=".csv" multiple>
        </div>
        <button id="analyze-btn" class="btn" disabled><i class="fas fa-chart-bar"></i> Analyze Files</button>
        <button id="clear-btn" class="clear-btn" style="margin-left: 10px;"><i class="fas fa-trash"></i> Clear Data</button>
        <div class="progress-container"><div class="progress-bar" id="progress-bar"></div></div>
    </div>
    <div class="results">
        <div id="stage1" class="tab-content active">
            <div class="card">
                <div class="tabs">
                    <div class="tab active" data-filter="all">All Matches</div>
                    <div class="tab" data-filter="home">Home Wins</div>
                    <div class="tab" data-filter="away">Away Wins</div>
                </div>
                <h2>Maximum Consensus Matches <span class="badge" id="stage1-badge">Fuzzy</span></h2>
                <div class="export-btn-container">
                    <button id="delete-unselected-btn" class="delete-btn">
                        <i class="fas fa-trash-alt"></i> Delete Unselected
                    </button>
                    <button id="export-home-btn" class="btn btn-secondary" style="background:var(--primary);">
                        <i class="fas fa-file-export"></i> Export Home Wins
                    </button>
                    <button id="export-away-btn" class="btn btn-secondary" style="background:var(--danger);">
                        <i class="fas fa-file-export"></i> Export Away Wins
                    </button>
                </div>
                <div class="stats">
                    <div class="stat-card">
                        <h3>Total Consensus Matches</h3>
                        <p id="total-matches">0</p>
                    </div>
                    <div class="stat-card">
                        <h3>Consensus Level</h3>
                        <p id="consensus-level">-</p>
                    </div>
                    <div class="stat-card">
                        <h3>Home Wins</h3>
                        <p id="home-wins">0</p>
                    </div>
                    <div class="stat-card">
                        <h3>Away Wins</h3>
                        <p id="away-wins">0</p>
                    </div>
                </div>
                <div style="overflow-x:auto;">
                    <table id="stage1-table">
                        <thead>
                            <tr>
                                <th>Select</th>
                                <th>Match</th>
                                <th>Time</th>
                                <th>Sources</th>
                                <th>Predictions</th>
                            </tr>
                        </thead>
                        <tbody id="stage1-results">
                            <tr>
                                <td colspan="5" class="empty-state">
                                    <i class="fas fa-futbol"></i>
                                    <p>Upload and analyze CSV files to see consensus matches</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    <div id="export-table-container" style="display:none;"></div>
</div>
<script>
const analyzeBtn = document.getElementById('analyze-btn');
const progressBar = document.getElementById('progress-bar');
const fileInput = document.getElementById('file-multi');
const customUpload = document.getElementById('custom-upload');
const uploadLabelText = document.getElementById('upload-label-text');
const exportHomeBtn = document.getElementById('export-home-btn');
const exportAwayBtn = document.getElementById('export-away-btn');
const deleteUnselectedBtn = document.getElementById('delete-unselected-btn');
const clearBtn = document.getElementById('clear-btn');
const tabs = document.querySelectorAll('.tab');
let selectedGroups = [];
let allMatchGroups = []; // Store all match groups for reference
let currentFilter = 'all'; // 'all', 'home', or 'away'

// Load data from localStorage if available
if (localStorage.getItem('footballPredictionsData')) {
    const savedData = JSON.parse(localStorage.getItem('footballPredictionsData'));
    allMatchGroups = savedData.allMatchGroups;
    selectedGroups = savedData.selectedGroups;
    currentFilter = savedData.currentFilter;
    updateStage1Results(allMatchGroups, savedData.consensusLevel);
    updateTabUI();
}

customUpload.addEventListener('dragover', (e) => { e.preventDefault(); customUpload.classList.add('dragover'); });
customUpload.addEventListener('dragleave', () => customUpload.classList.remove('dragover'));
customUpload.addEventListener('drop', (e) => {
    e.preventDefault();
    customUpload.classList.remove('dragover');
    fileInput.files = e.dataTransfer.files;
    handleFileSelection();
});
customUpload.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', handleFileSelection);

function handleFileSelection() {
    const files = Array.from(fileInput.files);
    if (files.length >= 2 && files.length <= 10) {
        uploadLabelText.textContent = `${files.length} files selected`;
        analyzeBtn.disabled = false;
    } else {
        uploadLabelText.textContent = "Click or drag to upload files";
        analyzeBtn.disabled = true;
    }
}

// Fuzzy string matching for team names
function fuzzyMatch(str1, str2) {
    if (!str1 || !str2) return false;
    const clean = s => s.toLowerCase().replace(/[^a-z0-9]/g, '')
        .replace(/united/g, 'utd')
        .replace(/football/g, 'fc')
        .replace(/club/g, 'c')
        .replace(/sporting/g, 'sp')
        .replace(/athletic/g, 'ath')
        .replace(/association/g, 'as')
        .replace(/wanderers/g, 'wds');
    const a = clean(str1), b = clean(str2);
    if (a === b) return true;
    if (a.includes(b) || b.includes(a)) return true;
    return false;
}

// Month/abbr to score mapping
function monthToNum(str) {
    const map = {
        'jan': 1, 'feb': 2, 'mar': 3, 'apr': 4, 'may': 5, 'jun': 6,
        'jul': 7, 'aug': 8, 'sep': 9, 'oct': 10, 'nov': 11, 'dec': 12
    };
    str = str.toLowerCase();
    return map[str] !== undefined ? map[str] : null;
}
function normalizeScore(pred) {
    if (!pred) return pred;
    pred = pred.replace(/\s+/g, '').replace(':', '-');
    let regexMonth = /^(\d+)[-](jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)$/i;
    let regexMonthRev = /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[-](\d+)$/i;
    let m = pred.match(regexMonth);
    if (m) {
        let left = m[1], right = monthToNum(m[2]);
        if (right !== null) return `${left}:${right}`;
    }
    m = pred.match(regexMonthRev);
    if (m) {
        let left = monthToNum(m[1]), right = m[2];
        if (left !== null) return `${left}:${right}`;
    }
    let score = pred.match(/^(\d+)[-:](\d+)$/);
    if (score) return `${score[1]}:${score[2]}`;
    return pred;
}

// Normalize prediction to win/draw type
function predictionType(pred) {
    if (!pred) return '';
    pred = normalizeScore(pred);
    const txt = pred.toString().toLowerCase().trim();
    if (['draw', 'x'].includes(txt)) return 'draw';
    if (txt === '1') return 'home';
    if (txt === '2') return 'away';
    const score = txt.match(/^(\d+):(\d+)$/);
    if (score) {
        if (parseInt(score[1]) > parseInt(score[2])) return 'home';
        if (parseInt(score[2]) > parseInt(score[1])) return 'away';
        return 'draw';
    }
    return '';
}

// Parse CSV file, output array of match objects
function parseCSV(file, index) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            const lines = content.split('\n').filter(l=>l.trim());
            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
            const matches = [];
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                if (values.length < 2) continue;
                const match = {};
                for (let j = 0; j < headers.length; j++) {
                    let value = values[j] ? values[j].trim().replace(/"/g, '') : '';
                    if (headers[j].toLowerCase().includes('prediction') || headers[j].toLowerCase().includes('score')) {
                        value = normalizeScore(value);
                    }
                    match[headers[j]] = value;
                }
                match.source = `Source ${index+1}`;
                if (match['Home Team'] && match['Away Team']) {
                    match['Home Team'] = match['Home Team'].replace(/ FC$| Club$| Team$/i, '').trim();
                    match['Away Team'] = match['Away Team'].replace(/ FC$| Club$| Team$/i, '').trim();
                }
                matches.push(match);
            }
            resolve(matches);
        };
        reader.onerror = reject;
        reader.readAsText(file);
    });
}

// Group matches by fuzzy home/away team, include all predictions
function extractMaximumConsensusMatches(allFileMatches) {
    const matchGroups = [];
    allFileMatches.forEach((matches, fileIdx) => {
        matches.forEach(match => {
            let found = false;
            for (const group of matchGroups) {
                const ref = group.ref;
                if (
                    fuzzyMatch(match['Home Team'], ref['Home Team']) &&
                    fuzzyMatch(match['Away Team'], ref['Away Team'])
                ) {
                    group.instances.push({...match, fileIdx});
                    found = true;
                    break;
                }
            }
            if (!found) matchGroups.push({
                ref: match,
                instances: [{...match, fileIdx}]
            });
        });
    });
    let maxSources = Math.max(...matchGroups.map(g => {
        const uniqueSources = new Set(g.instances.map(m => m.fileIdx));
        return uniqueSources.size;
    }), 0);
    // Only groups present in maxSources files
    const resultGroups = matchGroups.filter(g => {
        const uniqueSources = new Set(g.instances.map(m => m.fileIdx));
        return uniqueSources.size === maxSources;
    });
    return {matches: resultGroups, consensusLevel: maxSources};
}

// Get prediction type for a match group
function getGroupPredictionType(group) {
    let types = group.instances.map(inst => predictionType(
        inst['Prediction'] || inst['Score Prediction'] || inst['Correct Score'] || '-'
    ));
    const firstType = types[0];
    if (firstType && types.every(t => t === firstType)) {
        return firstType;
    }
    return '';
}

// Automatic selection: only matches with same prediction type in all sources are auto-selected
function autoSelectGroups(matchGroups) {
    const selected = [];
    matchGroups.forEach((group, idx) => {
        const predType = getGroupPredictionType(group);
        if (predType && predType !== 'draw') {
            selected.push(idx);
        }
    });
    return selected;
}

// Format time with +3 hours for local time
function formatTimeWithLocal(timeStr) {
    if (!timeStr) return '';
    
    try {
        // Try to parse as ISO date
        let date = new Date(timeStr);
        if (!isNaN(date.getTime())) {
            // Add 3 hours for local time
            const localDate = new Date(date.getTime() + (3 * 60 * 60 * 1000));
            return {
                original: date.toLocaleString(),
                local: localDate.toLocaleString(),
                simple: date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                localSimple: localDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})
            };
        }
        
        // Try to parse as simple time (HH:MM)
        const timeMatch = timeStr.match(/^(\d{1,2}):(\d{2})$/);
        if (timeMatch) {
            const hours = parseInt(timeMatch[1]);
            const mins = parseInt(timeMatch[2]);
            const date = new Date();
            date.setHours(hours, mins, 0, 0);
            // Add 3 hours for local time
            const localDate = new Date(date.getTime() + (3 * 60 * 60 * 1000));
            return {
                original: date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                local: localDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                simple: date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                localSimple: localDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})
            };
        }
    } catch (e) {
        console.error('Error parsing time:', e);
    }
    
    // Fallback - return as is
    return {
        original: timeStr,
        local: timeStr,
        simple: timeStr,
        localSimple: timeStr
    };
}

function updateStage1Results(matchGroups, consensusLevel) {
    allMatchGroups = matchGroups; // Store all match groups
    selectedGroups = [];
    const tbody = document.getElementById('stage1-results');
    tbody.innerHTML = '';
    document.getElementById('total-matches').textContent = matchGroups.length;
    document.getElementById('consensus-level').textContent = consensusLevel > 0 ? consensusLevel + " sources" : "-";
    
    // Count home and away wins
    let homeWins = 0;
    let awayWins = 0;
    
    matchGroups.forEach(group => {
        const predType = getGroupPredictionType(group);
        if (predType === 'home') homeWins++;
        if (predType === 'away') awayWins++;
    });
    
    document.getElementById('home-wins').textContent = homeWins;
    document.getElementById('away-wins').textContent = awayWins;
    
    if (matchGroups.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="5" class="empty-state">
                    <i class="fas fa-futbol"></i>
                    <p>No consensus matches found.</p>
                </td>
            </tr>
        `;
        return;
    }
    
    const autoSelected = autoSelectGroups(matchGroups);
    matchGroups.forEach((group, idx) => {
        const homeTeam = Object.entries(group.instances.reduce((acc, m) => {
            acc[m['Home Team']] = (acc[m['Home Team']]||0)+1; return acc;
        }, {})).sort((a,b)=>b[1]-a[1])[0][0];
        const awayTeam = Object.entries(group.instances.reduce((acc, m) => {
            acc[m['Away Team']] = (acc[m['Away Team']]||0)+1; return acc;
        }, {})).sort((a,b)=>b[1]-a[1])[0][0];
        const time = Object.entries(group.instances.reduce((acc,m)=>{
            const t = m['Time']||m['Date']||m['DateTime']||'';
            if (t) acc[t]=(acc[t]||0)+1; return acc;
        },{})).sort((a,b)=>b[1]-a[1])[0]?.[0] || '';
        const formattedTime = formatTimeWithLocal(time);
        const sources = group.instances.map(m => m.source);
        const predictionRows = group.instances.map(m => {
            let pred = m['Prediction']||m['Score Prediction']||m['Correct Score']||'-';
            return `<div><span class="source-badge">${m.source}</span>: <strong>${pred}</strong></div>`;
        }).join('');
        
        // Determine prediction type for styling
        const predType = getGroupPredictionType(group);
        
        const row = document.createElement('tr');
        row.className = 'match-row';
        if (predType === 'home') row.classList.add('home-win');
        if (predType === 'away') row.classList.add('away-win');
        
        row.innerHTML = `
            <td>
                <button class="select-btn${autoSelected.includes(idx) ? ' selected' : ''}" data-idx="${idx}">${autoSelected.includes(idx) ? 'Selected' : 'Select'}</button>
            </td>
            <td>
                ${homeTeam} vs ${awayTeam}
                <div class="match-time">${formattedTime.simple}</div>
            </td>
            <td>
                ${formattedTime.simple}
                ${formattedTime.localSimple !== formattedTime.simple ? 
                    `<div class="local-time">${formattedTime.localSimple} (local +3)</div>` : ''}
            </td>
            <td>
                <div class="sources-list">
                    ${sources.map(s => `<span class="source-badge">${s}</span>`).join('')}
                </div>
            </td>
            <td>
                ${predictionRows}
            </td>
        `;
        
        if (autoSelected.includes(idx)) {
            row.classList.add('highlight');
            selectedGroups.push(group);
        }
        
        // Apply filter
        if (currentFilter === 'all' || 
            (currentFilter === 'home' && predType === 'home') || 
            (currentFilter === 'away' && predType === 'away')) {
            tbody.appendChild(row);
        }
    });
    
    // Add select/deselect logic
    const selectBtns = document.querySelectorAll('.select-btn');
    selectBtns.forEach(btn => {
        btn.addEventListener('click', function() {
            const idx = parseInt(this.dataset.idx);
            const tr = this.closest('tr');
            if (btn.classList.contains('selected')) {
                btn.classList.remove('selected');
                btn.textContent = 'Select';
                tr.classList.remove('highlight');
                selectedGroups = selectedGroups.filter(g => g !== matchGroups[idx]);
            } else {
                btn.classList.add('selected');
                btn.textContent = 'Selected';
                tr.classList.add('highlight');
                selectedGroups.push(matchGroups[idx]);
            }
            saveToLocalStorage(consensusLevel);
        });
    });
    
    saveToLocalStorage(consensusLevel);
}

function updateTabUI() {
    tabs.forEach(tab => {
        tab.classList.remove('active');
        if (tab.dataset.filter === currentFilter) {
            tab.classList.add('active');
        }
    });
}

function filterMatches(filter) {
    currentFilter = filter;
    updateTabUI();
    
    const rows = document.querySelectorAll('.match-row');
    rows.forEach(row => {
        const idx = parseInt(row.querySelector('.select-btn').dataset.idx);
        const group = allMatchGroups[idx];
        const predType = getGroupPredictionType(group);
        
        if (filter === 'all' || 
            (filter === 'home' && predType === 'home') || 
            (filter === 'away' && predType === 'away')) {
            row.style.display = '';
        } else {
            row.style.display = 'none';
        }
    });
}

function saveToLocalStorage(consensusLevel) {
    const data = {
        allMatchGroups,
        selectedGroups,
        currentFilter,
        consensusLevel
    };
    localStorage.setItem('footballPredictionsData', JSON.stringify(data));
}

function clearData() {
    localStorage.removeItem('footballPredictionsData');
    allMatchGroups = [];
    selectedGroups = [];
    currentFilter = 'all';
    document.getElementById('stage1-results').innerHTML = `
        <tr>
            <td colspan="5" class="empty-state">
                <i class="fas fa-futbol"></i>
                <p>Upload and analyze CSV files to see consensus matches</p>
            </td>
        </tr>
    `;
    document.getElementById('total-matches').textContent = '0';
    document.getElementById('consensus-level').textContent = '-';
    document.getElementById('home-wins').textContent = '0';
    document.getElementById('away-wins').textContent = '0';
    fileInput.value = '';
    uploadLabelText.textContent = "Click or drag to upload files";
    analyzeBtn.disabled = true;
    updateTabUI();
}

function exportSelectedToPNG(type) {
    const groupsToExport = selectedGroups.filter(group => {
        const predType = getGroupPredictionType(group);
        if (type === 'home') return predType === 'home';
        if (type === 'away') return predType === 'away';
        return true;
    });
    
    if (!groupsToExport.length) {
        alert(`No ${type} wins selected to export.`);
        return;
    }
    
    const container = document.getElementById('export-table-container');
    container.innerHTML = '';

    // Build export table for PNG
    const table = document.createElement('table');
    table.className = 'export-png-table';
    
    // Title
    const title = document.createElement('div');
    title.className = 'export-png-title';
    title.textContent = 'Selected Football Predictions';
    container.appendChild(title);
    
    // Type badge
    const typeBadge = document.createElement('div');
    typeBadge.className = `export-type-badge ${type}-badge`;
    typeBadge.textContent = type === 'home' ? 'HOME WINS' : 'AWAY WINS';
    container.appendChild(typeBadge);

    // Table header
    const thead = document.createElement('thead');
    thead.innerHTML = `
        <tr>
            <th style="width:90px;">Time</th>
            <th style="width:230px;">Teams Playing</th>
            <th style="width:320px;">Predictions</th>
        </tr>
    `;
    table.appendChild(thead);

    // Table body
    const tbody = document.createElement('tbody');
    groupsToExport.forEach(group => {
        // Most common team names & time
        const homeTeam = Object.entries(group.instances.reduce((acc, m) => {
            acc[m['Home Team']] = (acc[m['Home Team']]||0)+1; return acc;
        }, {})).sort((a,b)=>b[1]-a[1])[0][0];
        const awayTeam = Object.entries(group.instances.reduce((acc, m) => {
            acc[m['Away Team']] = (acc[m['Away Team']]||0)+1; return acc;
        }, {})).sort((a,b)=>b[1]-a[1])[0][0];
        const time = Object.entries(group.instances.reduce((acc,m)=>{
            const t = m['Time']||m['Date']||m['DateTime']||'';
            if (t) acc[t]=(acc[t]||0)+1; return acc;
        },{})).sort((a,b)=>b[1]-a[1])[0]?.[0] || '';
        const formattedTime = formatTimeWithLocal(time);

        // Merge teams cell
        const teamsCell = document.createElement('td');
        teamsCell.className = 'team-cell';
        teamsCell.colSpan = 1;
        teamsCell.innerHTML = `${homeTeam} <span style="color:#999;font-weight:400">vs</span> ${awayTeam}`;

        // Merge predictions - one row per source, nice format
        const predictionsCell = document.createElement('td');
        predictionsCell.className = 'prediction-cell';
        predictionsCell.style.textAlign = 'left';
        predictionsCell.innerHTML = group.instances.map(inst => {
            const pred = inst['Prediction']||inst['Score Prediction']||inst['Correct Score']||'-';
            return `<span style="display:inline-block;margin-bottom:3px;"><strong>${inst.source}:</strong> ${pred}</span>`;
        }).join('<br>');

        const tr = document.createElement('tr');
        if (type === 'home') tr.classList.add('home-win-export');
        if (type === 'away') tr.classList.add('away-win-export');
        
        // Arrange columns: time | teams | predictions
        const timeCell = document.createElement('td');
        timeCell.innerHTML = `<div class="export-png-time">${formattedTime.simple}</div>`;
        if (formattedTime.localSimple !== formattedTime.simple) {
            timeCell.innerHTML += `<div class="local-time">${formattedTime.localSimple} (local +3)</div>`;
        }
        tr.appendChild(timeCell);
        tr.appendChild(teamsCell);
        tr.appendChild(predictionsCell);
        tbody.appendChild(tr);
    });
    table.appendChild(tbody);

    container.appendChild(table);
    container.style.display = 'block';

    // Hide export buttons for screenshot
    exportHomeBtn.style.visibility = 'hidden';
    exportAwayBtn.style.visibility = 'hidden';

    html2canvas(container, {
        scale: 2,
        backgroundColor: '#f8f9fa'
    }).then(canvas => {
        exportHomeBtn.style.visibility = 'visible';
        exportAwayBtn.style.visibility = 'visible';
        container.style.display = 'none';
        // Download PNG
        const link = document.createElement('a');
        link.download = `selected-${type}-wins.png`;
        link.href = canvas.toDataURL('image/png');
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });
}

function deleteUnselectedMatches() {
    if (!allMatchGroups.length) return;
    
    // Keep only selected groups
    allMatchGroups = allMatchGroups.filter((group, idx) => {
        return selectedGroups.includes(group);
    });
    
    // Update the table with only selected matches
    updateStage1Results(allMatchGroups, allMatchGroups.length > 0 ? 
        document.getElementById('consensus-level').textContent.replace(' sources', '') : 0);
    
    // Clear selected groups (they're all that's left now)
    selectedGroups = [...allMatchGroups];
    saveToLocalStorage(document.getElementById('consensus-level').textContent.replace(' sources', ''));
}

analyzeBtn.addEventListener('click', async function() {
    const files = Array.from(fileInput.files);
    if (files.length < 2 || files.length > 10) {
        alert('Please select between 2 and 10 CSV files.');
        return;
    }
    analyzeBtn.disabled = true;
    analyzeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analyzing...';
    progressBar.style.width = '0%';
    try {
        const parsePromises = files.map((file, index) => parseCSV(file, index));
        const allFileMatches = await Promise.all(parsePromises);
        progressBar.style.width = '40%';
        const {matches, consensusLevel} = extractMaximumConsensusMatches(allFileMatches);
        progressBar.style.width = '100%';
        updateStage1Results(matches, consensusLevel);
    } catch (error) {
        console.error('Error analyzing files:', error);
        alert('An error occurred while analyzing the files. Please check the console for details.');
    } finally {
        analyzeBtn.disabled = false;
        analyzeBtn.innerHTML = '<i class="fas fa-chart-bar"></i> Analyze Files';
        setTimeout(() => {
            document.querySelector('.results').scrollIntoView({behavior: 'smooth'});
        }, 300);
    }
});

// Tab click handlers
tabs.forEach(tab => {
    tab.addEventListener('click', () => {
        currentFilter = tab.dataset.filter;
        filterMatches(currentFilter);
        saveToLocalStorage(document.getElementById('consensus-level').textContent.replace(' sources', ''));
    });
});

exportHomeBtn.addEventListener('click', () => exportSelectedToPNG('home'));
exportAwayBtn.addEventListener('click', () => exportSelectedToPNG('away'));
deleteUnselectedBtn.addEventListener('click', deleteUnselectedMatches);
clearBtn.addEventListener('click', clearData);
</script>
</body>
</html>
